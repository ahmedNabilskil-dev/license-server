-- Create licenses table
CREATE TABLE licenses (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  license_key TEXT UNIQUE NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('one_time', 'subscription', 'trial')),
  status TEXT NOT NULL CHECK (status IN ('active', 'inactive', 'expired', 'canceled', 'past_due', 'trialing')) DEFAULT 'active',
  customer_email TEXT NOT NULL,
  customer_name TEXT,
  transaction_id TEXT,
  subscription_id TEXT,
  expires_at TIMESTAMP WITH TIME ZONE,
  max_activations INTEGER DEFAULT 1,
  is_trial BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  canceled_at TIMESTAMP WITH TIME ZONE,
  cancellation_reason TEXT
);

-- Indexes for licenses table
CREATE INDEX idx_licenses_license_key ON licenses(license_key);
CREATE INDEX idx_licenses_customer_email ON licenses(customer_email);
CREATE INDEX idx_licenses_subscription_id ON licenses(subscription_id);
CREATE INDEX idx_licenses_transaction_id ON licenses(transaction_id);
CREATE INDEX idx_licenses_status ON licenses(status);
CREATE INDEX idx_licenses_expires_at ON licenses(expires_at);
CREATE INDEX idx_licenses_created_at ON licenses(created_at);


/////////////////////////////////////////////////////////////////////

-- Create activations table
CREATE TABLE activations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  license_id UUID NOT NULL REFERENCES licenses(id) ON DELETE CASCADE,
  device_id TEXT NOT NULL,
  device_info JSONB DEFAULT '{}',
  activated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_validation TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  deactivated_at TIMESTAMP WITH TIME ZONE,
  is_active BOOLEAN DEFAULT true,
  is_trial_activation BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for activations table
CREATE INDEX idx_activations_license_id ON activations(license_id);
CREATE INDEX idx_activations_device_id ON activations(device_id);
CREATE INDEX idx_activations_license_device ON activations(license_id, device_id);
CREATE INDEX idx_activations_is_active ON activations(is_active);
CREATE INDEX idx_activations_last_validation ON activations(last_validation);

////////////////////////////////////////////////////////////////////////////////

-- Create webhook_logs table for debugging
CREATE TABLE webhook_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  event_type TEXT NOT NULL,
  paddle_event_id TEXT NOT NULL,
  payload JSONB NOT NULL,
  processed BOOLEAN DEFAULT false,
  error_message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for webhook_logs table
CREATE INDEX idx_webhook_logs_event_type ON webhook_logs(event_type);
CREATE INDEX idx_webhook_logs_paddle_event_id ON webhook_logs(paddle_event_id);
CREATE INDEX idx_webhook_logs_created_at ON webhook_logs(created_at);
CREATE INDEX idx_webhook_logs_processed ON webhook_logs(processed);

/////////////////////////////////////////////////////////////////////////////////

-- Create email_logs table to track sent emails
CREATE TABLE email_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  recipient_email TEXT NOT NULL,
  subject TEXT NOT NULL,
  template_type TEXT NOT NULL,
  license_id UUID REFERENCES licenses(id),
  sent_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  status TEXT DEFAULT 'sent',
  error_message TEXT
);

-- Indexes for email_logs table
CREATE INDEX idx_email_logs_recipient_email ON email_logs(recipient_email);
CREATE INDEX idx_email_logs_sent_at ON email_logs(sent_at);
CREATE INDEX idx_email_logs_license_id ON email_logs(license_id);

/////////////////////////////////////////////////////////////////////////////

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger for licenses table
CREATE TRIGGER update_licenses_updated_at 
    BEFORE UPDATE ON licenses 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

////////////////////////////////////////////////////////////////////////


    -- Enable RLS on all tables
ALTER TABLE licenses ENABLE ROW LEVEL SECURITY;
ALTER TABLE activations ENABLE ROW LEVEL SECURITY;
ALTER TABLE webhook_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_logs ENABLE ROW LEVEL SECURITY;

-- Create policies for backend service access (adjust based on your needs)
-- Policy to allow all operations for service role (backend)
CREATE POLICY "Service full access" ON licenses FOR ALL USING (true);
CREATE POLICY "Service full access" ON activations FOR ALL USING (true);
CREATE POLICY "Service full access" ON webhook_logs FOR ALL USING (true);
CREATE POLICY "Service full access" ON email_logs FOR ALL USING (true);

///////////////////////////////////////////////////////////////////////////////

-- Create view for license overview
CREATE VIEW license_overview AS
SELECT 
    l.id,
    l.license_key,
    l.type,
    l.status,
    l.customer_email,
    l.customer_name,
    l.expires_at,
    l.max_activations,
    l.is_trial,
    l.created_at,
    COUNT(a.id) as total_activations,
    COUNT(a.id) FILTER (WHERE a.is_active = true) as active_activations,
    MAX(a.last_validation) as last_validation
FROM licenses l
LEFT JOIN activations a ON l.id = a.license_id
GROUP BY l.id;

-- Create view for subscription analytics
CREATE VIEW subscription_analytics AS
SELECT 
    type,
    status,
    COUNT(*) as total_licenses,
    COUNT(*) FILTER (WHERE expires_at > NOW()) as active_licenses,
    COUNT(*) FILTER (WHERE is_trial = true) as trial_licenses,
    AVG(max_activations) as avg_activations
FROM licenses
GROUP BY type, status;


///////////////////////////////////////////////////////////////////////


-- Insert sample trial license (for testing)
INSERT INTO licenses (
    license_key,
    type,
    status,
    customer_email,
    customer_name,
    expires_at,
    max_activations,
    is_trial
) VALUES (
    'sample_trial_license_key_123',
    'subscription',
    'trialing',
    'test@example.com',
    'Test User',
    NOW() + INTERVAL '7 days',
    3,
    true
);

-- Insert sample activation
INSERT INTO activations (
    license_id,
    device_id,
    device_info
) VALUES (
    (SELECT id FROM licenses WHERE license_key = 'sample_trial_license_key_123'),
    'sample_device_id_123',
    '{"os": "Windows", "version": "10.0.19041"}'
);

/////////////////////////////////////////////////////////////////////////


-- Function to check if license can be activated
CREATE OR REPLACE FUNCTION can_activate_license(
    license_id UUID,
    device_id TEXT
) RETURNS TABLE(
    can_activate BOOLEAN,
    reason TEXT,
    max_activations INTEGER,
    current_activations INTEGER
) AS $$
DECLARE
    license_record RECORD;
    active_count INTEGER;
BEGIN
    -- Get license information
    SELECT * INTO license_record 
    FROM licenses 
    WHERE id = license_id;
    
    -- Check if license exists
    IF license_record IS NULL THEN
        RETURN QUERY SELECT false, 'License not found', 0, 0;
        RETURN;
    END IF;
    
    -- Check if license is active
    IF license_record.status NOT IN ('active', 'trialing') THEN
        RETURN QUERY SELECT false, 'License is ' || license_record.status, 
                      license_record.max_activations, 0;
        RETURN;
    END IF;
    
    -- Check if license is expired
    IF license_record.expires_at IS NOT NULL AND license_record.expires_at < NOW() THEN
        RETURN QUERY SELECT false, 'License expired', 
                      license_record.max_activations, 0;
        RETURN;
    END IF;
    
    -- Check if device is already activated
    IF EXISTS (
        SELECT 1 FROM activations 
        WHERE license_id = license_record.id 
        AND device_id = device_id 
        AND is_active = true
    ) THEN
        RETURN QUERY SELECT true, 'Device already activated', 
                      license_record.max_activations, 0;
        RETURN;
    END IF;
    
    -- Count active activations
    SELECT COUNT(*) INTO active_count 
    FROM activations 
    WHERE license_id = license_record.id 
    AND is_active = true;
    
    -- Check activation limit
    IF active_count >= license_record.max_activations THEN
        RETURN QUERY SELECT false, 'Maximum devices reached', 
                      license_record.max_activations, active_count;
        RETURN;
    END IF;
    
    -- All checks passed
    RETURN QUERY SELECT true, 'Can activate', 
                  license_record.max_activations, active_count;
END;
$$ LANGUAGE plpgsql;

-- Function to deactivate expired licenses
CREATE OR REPLACE FUNCTION deactivate_expired_licenses()
RETURNS INTEGER AS $$
DECLARE
    expired_count INTEGER;
BEGIN
    -- Update licenses to expired status
    WITH updated AS (
        UPDATE licenses 
        SET status = 'expired'
        WHERE expires_at < NOW() 
        AND status IN ('active', 'trialing')
        RETURNING id
    )
    SELECT COUNT(*) INTO expired_count FROM updated;
    
    -- Deactivate all activations for expired licenses
    UPDATE activations 
    SET is_active = false, 
        deactivated_at = NOW()
    WHERE license_id IN (
        SELECT id FROM licenses 
        WHERE expires_at < NOW() 
        AND status = 'expired'
    ) AND is_active = true;
    
    RETURN expired_count;
END;
$$ LANGUAGE plpgsql;


////////////////////////////////////////////////////////////////////////



-- Schedule daily cleanup of expired licenses (requires pg_cron extension)
SELECT cron.schedule(
    'deactivate-expired-licenses',
    '0 2 * * *', -- Daily at 2 AM
    'SELECT deactivate_expired_licenses()'
);

-- Schedule weekly cleanup of old webhook logs
SELECT cron.schedule(
    'cleanup-old-webhook-logs',
    '0 3 * * 0', -- Weekly on Sunday at 3 AM
    'DELETE FROM webhook_logs WHERE created_at < NOW() - INTERVAL ''30 days'''
);

////////////////////////////////////////////////////////////////////

Installation Instructions
Go to Supabase Dashboard → Your project → SQL Editor

Run the queries in this order:

Tables (1-4)

Triggers (5)

RLS Policies (6) - Optional

Views (7) - Optional

Functions (9) - Optional but recommended

Sample data (8) - For testing only

Set up environment variables in your backend:

env
SUPABASE_URL=your_supabase_project_url
SUPABASE_ANON_KEY=your_supabase_anon_key
This database schema provides:

Complete license management

Device activation tracking

Webhook logging for debugging

Email tracking

Automatic cleanup of expired licenses

Useful views for analytics

Proper indexing for performance

The schema is optimized for the licensing system we've built and includes all necessary tables for the backend to function properly!



